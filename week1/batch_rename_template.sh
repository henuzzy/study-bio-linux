#!/bin/bash  # 指定脚本解释器为 bash，确保脚本用 bash 来执行
# batch_rename.sh - 批量重命名脚本模板  # 脚本名称及用途简述
# 功能: 将 test_1.txt, test_2.txt, ..., test_100.txt 重命名为 sample_01.data, sample_02.data, ..., sample_100.data  # 功能说明，示例输入输出

# 设置日志文件  # 注释: 错误和诊断信息将重定向到该文件
LOG_FILE="rename.log"  # 定义日志文件的变量，后续用于重定向标准错误
exec 2> "$LOG_FILE"  # 将脚本的标准错误（文件描述符 2）重定向到日志文件，便于记录错误和调试信息

echo "开始批量重命名任务..." >&2  # 向标准错误打印开始信息（输出同样进入日志文件）
date >&2  # 输出当前日期时间到标准错误（记录日志的时间戳）

# TODO: 在这里编写你的代码  # 提示占位，提示用户在此处插入自定义逻辑
# 提示:  # 说明: 给出实现思路帮助用户完成脚本
# 1. 使用 for 循环遍历文件  # 提示：使用循环处理序号范围或文件列表
# 2. 使用变量存储新旧文件名  # 提示：使用变量来构造要重命名的文件名
# 3. 使用 mv 命令进行重命名  # 提示：使用 mv 实际完成重命名操作
# 4. 添加错误处理  # 提示：检查文件是否存在并记录警告或错误

# 示例框架:  # 下面给出一个可直接运行的示例实现
for i in {1..100}; do  # 使用 brace expansion 遍历数字 1 到 100（i 为循环变量）
    old_name="test_${i}.txt"  # 构造旧文件名，例如 test_1.txt（字符串插值）
    # 格式化数字，确保两位数  # 注：使输出数字为两位格式（01, 02, ...）
    new_name=$(printf "sample_%02d.data" $i)  # 使用 printf 将数字格式化为两位并构造新文件名，例如 sample_01.data
    # 检查文件是否存在  # 在尝试重命名前，先确认旧文件真实存在
    if [ -f "$old_name" ]; then  # -f 判断旧文件是否存在且为常规文件（存在返回真）
        mv "$old_name" "$new_name"  # 使用 mv 命令将旧文件重命名为新文件
        echo "重命名: $old_name -> $new_name" >&2  # 将重命名操作记录到日志（写到标准错误）
    else
        echo "警告: 文件 $old_name 不存在" >&2  # 如果文件不存在，则记录一条警告到日志
    fi
done  # 结束循环

echo "批量重命名完成!" >&2  # 输出完成提示到日志
date >&2  # 输出结束的时间戳到日志
